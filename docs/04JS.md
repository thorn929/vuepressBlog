课程回顾：

​	数组：多个数据组合，var 数组名 = [值1，值2，值3......];

​	取值：数组[下标]

​	赋值：数组[下标] = 值;

​	下标：从0，length-1

​	数组遍历：for，复杂数组：[[],[],[]];

小娜

## 冒泡排序

逻辑：有两个水杯（一个5升，一个6升），还有无限的谁；要求：让一个被子装3升水

冒泡排序：

​	1、确认一个数组能够交换多少趟才可以得出结果【长度-1】

​	2、每一趟比较次数是多少次【长度-趟数】

​	3、把数组的前一个和后一个数比较，如果前一个数大于后一个数，那么就去交换位置

# 04JavaScript基础

## 核心知识点

> ### 能够封装自定义函数



## 函数

### 为什么要学函数？

函数：一段功能代码的封装

​	一般来说，这段封装起来的代码都是具有某些功能的

定义函数：function fn(){} ,var fn = function (){}

调用函数：函数名();

参数：形参，实参

```javascript
 1. 在若干个页面中要求 1到100之间的数字之和
```

### 什么是函数？

目的：

​	1、了解函数作用【代码封装，重复使用】

 	2、会定义函数并且调用【function 函数名 () {}，调用：函数名();】

> #### 函数的概念

```javascript
  函数： 可以封装一段特定功能代码，然后通过函数名调用，实现对该段代码重复使用
  
  函数：一段代码的封装
```

> #### 函数的作用

```javascript
   实现代码的重复使用。
   
   	  ✔ 对分散代码整合（封装）
      ✔ 重复使用
```

### 创建函数

> #### 方式一： 函数声明及执行方式（推荐）
>
> ```javascript
> ☞ 函数的声明：
> 
> function  自定义函数名() {
>     //一堆代码
>     具体的功能代码
>     //函数体
>   
> }
> 注意：
> 	 1. 由于函数是用来实现某种特定功能代码，所以一般我们设置函数名的时候，以动词开始。
>      2. 函数不能自己执行代码，需要通过函数名调用实现代码的执行
>  
>  ☞ 调用函数（执行函数）
>  
>      函数名();  //函数的调用
> ```
>
> #### 方式二：函数表达式（字面量）及执行方式（了解）
>
> ```javascript
> var  fn = function () {
>     
> }   
> 
> fn();
> ```
>
> ### 课堂一练
>
> ```javascript
> 1. 将比较数字大小封装到一个函数中
> ```

### 函数的参数

```javascript
 思考： 利用函数如何计算任意两个数字之和？
```

> #### 形参
>
> ```javascript
> 在 函数创建时，在小扩号中定义的变量
> 
> 语法：
> 
> 形参：占位符，本身没有真实数据
> function 函数名(形式参数，形参,形参,形参...) {//形参，就是一个占位符，命名规则和规范和变量一样
> 	//函数体
> }
> 
> 
> 注意：
> 	  1 函数也可以做为参数进行传递
> ```
>
> #### 实参
>
> ```javascript
> 实参，在函数调用时，在小扩号中所传入的实际的数据。
> 
> 语法：
> 实参：真实数据
> 函数名(实际参数，数据,数据,数据...);   //实参，就是实际的数据
> ```
>
> 函数：一段代码的封装
>
> ​	定义：function 函数名 (形参1，形参2，......) {函数体}
>
> ​	调用：函数名(实参1，实参2，......);
>
> 
>
> #### 课堂一练
>
> ```javascript
> ☞ 求圆的面积   PI * r * r   
> 
> ☞ 求 n 到 m 之间的数字之和
> 
> ☞ 求3个数中的最大值  
> 
> ☞ 判断一个数是奇数还是偶数  
> ```

### 函数的返回值

```javascript
 思考： 如何在函数外面获取到上面代码计算出的任意两个数之和？
 
 注意：函数内部的值不可以直接拿到函数外面用
```

> #### 返回值：函数执行完后，可以把执行的结果 通过 **return 语法** 返回给 调用者
>
> 目的：把一个值返回到函数外面;
>
> ```javascript
> function add(num1，num2){
>  //函数体
>  return num1 + num2; // 注意：return 后的代码不执行
> }
> var resNum = add(21,6); // 调用函数，传入 两个实参，并通过 resNum 接收函数返回值
> alert(resNum);// 27
> 
> 注意：
>     1. 如果函数没有显示的使用 return语句 ，那么函数有默认的返回值：undefined
>     2. 如果函数中写了return语句，后面没有写任何其他内容，那么函数的返回值依然是 undefined
>     3. 一个函数只能有一个返回值
>     4. return 代码执行完成后，后面的代码不再执行
>     5. 函数也可以作为返回值（理解）
> ```
>
> #### 课堂一练
>
> ```javascript
>  1. 获取数组中最大值，并返回
> 
>  2. 将一个数组中所有偶数添加到一个新数组中返回，并计算新数组总和。
> ```

冒泡排序： 先找趟数，再找每趟次数，每次比较交换

小娜练习

函数：一段功能代码的封装

​	定义函数：function 函数名 (形参，形参) {函数体}

​	调用函数：函数名（实参，实参）;

return：返回值

​	1、返回调用的位置

​	2、return不写或者return后面不写值，返回的是undefiend

​	3、return后面的代码一律不执行

在函数里面用var定义的变量，不能直接拿到函数外面用


### 课后练习

```javascript
1. 写一个函数，实现对数字数组的排序。
2. 写一个函数，用户输入任意两个不同数字,返回最后的最大值
3. 写一个函数，判断是否是闰年【能被4整除且不能被100整除，或者能被400整除】
```

## 函数其他部分

### arguments的使用

```javascript
☞ 思考： 
	 1. 如果一个函数的参数个数不确定该如何获取？
     2. 演示console.log()中不同个数参数的效果
     3. 介绍arguments对象
     
☞ 通过 arguments获取到函数参数的个数 【不确定函数到底有多少个参数】

☞ 总结：
	 1. 如果函数参数不确定，可以定义函数的时候不写参数，通过arguments获取
     2. 如果函数的参数确定，那么推荐定义函数的时候写参数
```

### arguments案例

```javascript
 1. 求任意个数中的最大值
 
 2. 求任意个数的和
 
 3. 求n 个数的最大值  
```

### 匿名函数和自调用函数

```javascript
☞ 匿名函数： 没有函数名的函数
例如：
var  fn = function () {
    
}

☞总结：
	  1. 匿名函数不能单独使用
      2. 可以将匿名函数赋值给一个变量
      3. 可以让匿名函数自己调用自己


☞ 自调用函数： 函数封装好，立即执行。
	总结：
    	1. 自调用函数可以是命名函数也可以是匿名函数
        2. ( function () {} )(); 

☞ 函数属于一种数据类型  

☞ 函数作为参数
	
☞ 函数可以为返回值

```

### 函数作用域及局部变量

> #### 作用域
>
> ```javascript
> ☞ 思考： 在函数内部定义的变量，在函数外部能否访问该变量
> 
>  作用域： 变量或者函数可以起作用的区域
>  
>  ◆ 全局作用域（全局变量）
>  	  1， 在script标签中或者js文件中定义的变量，在任何地方都可以访问
>       
>       2,  在函数内部声明变量不使用var关键字 （不建议使用）
>       
>  ◆ 局部作用域（局部变量）
>  	  1， 在函数内部定义的变量
> 	  2， 局部变量只能在定义变量的函数中使用
>       
>  ◆ 块级作用域 （目前所学版本没有，新版本语义中有块级作用域）
>        {
>           块级作用域
>        }  
>  	   1. 本质上块级作用域中的变量在外部不能访问
>        2. 但是在js中可以访问块级作用域的变量（证明js没有块级作用域）
> ```
>
> #### 全局作用域（全局变量）
>
> ```javascript
> 声明在所有函数外部的变量，可以所有地方使用
> 
> 案例：
> 	说出下列代码的运行结果？
> 	
> 	var age = 18;  
>     console.log(age); 
> 
>     function fn(){
>      console.log(age)
>     }
> 
>     fn();
> ```
>
> #### 局部作用域（局部变量）
>
> ```javascript
> 声明在某个函数内部的变量或函数的形参，只能在函数内部使用
> 
> 案例：
>      说出下列代码的运行结果？
>      
>      function fn(a){
>          a = 100;
>          var b = 200;  
>       }
> 	  
> 	  fn();
>       console.log(a); 
>       console.log(b); 
> ```

### 作用域链

![06-1](06-1.png)

```javascript
作用域链：
	当访问一个变量时，会先从本作用域中去找这个变量，若找不到则向上一级作用域中去找，依次类推，就形成了一个作用域链。

    
案例代码分析：
    var a = 1;
    function fn1(){
      var a = 2;
      function fn2(){
          console.log(a);   //a的值 
      }
      fn2()
    }
    fn1();

```

### 作用域案例分析

```javascript
1 分析代码执行结果
function  f1 () {
       num = 123;
    function f2 () {
       num = 789;
       console.log( num );
    }
    f2 ();
} 
var  num = 456;

f1();

```

### 预解析

```javascript
☞  思考1
	var num = 5; 
	console.log( num );

☞  思考2
	console.log( num );
    var  num = 5;

☞ 思考 3
  
    function f1 () {

    }

    f1();


☞ 思考4 

    f1();

    function f1 () {

    }

预解析：
提前解析带有var定义的变量，和解析带有函数名的函数
	1. js 代码执行先执行预解析
    
    2.  先进行变量提升： 把变量声明提升到当前作用域的最上面，不包括变量的赋值
    
    3. 函数提升： 把函数声明提升到当前作用域的最上面，不包括函数的调用
    
 JS一上来先预解析再执行
 	预解析：提前解析带有var的变量申明，和带有函数名的函数
    	变量：只定义不赋值
        函数：只定义不调用
    
   
    
预解析案例分析：
1. 
var  a  = 25;
function abc () {
    alert(a);
    var a = 10;
}

abc();

2. 
console.log(a)
function a () {
    console.log("aa");
}

var a = 1;
console.log(a);


注意：
	 1. 如果函数名和变量名一样，函数优先
     
     
 3.
var sum = 10;
fun ();
function fun () {
    console.log( num );
    var num = 20;
}

 4.
var  a  = 18;
f1();
function f1 () {
    var b = 9;
    console.log(a);
    console.log(b);
    var a = 123;
}

5.
f1();
console.log(c);
console.log(b);
console.log(a);
function f1 () {
    var a = b = c = 9;
    console.log(a);
    console.log(b);
    console.log(c);
}
```



### 代码规范

```javascript
 1, 命名规范
	 变量，函数的命名必须有含义
     ◆ 变量 的名称一般用名词【user_age】
     ◆ 函数 的名称一般用动词【getMax】

  2，变量规范
  	 ◆ 操作符 前后 加 空格【var n = 3；】 n <= m
     var b = 2;
  3， 空格规范
  	  if () {
      
      }
          
     for () {
          
      }    

	 var ary = [1, 2, 3, 4];


     function fn () {

      }

```

